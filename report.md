# 图像视频编码大实验

陈嘉杰 2017011484

## Exp1 Are they equivalent in effect?

### 子任务1 转换为灰度图片

见代码 `grayscale.py`，直接采用 PIL 的相关函数即可。

原图：

![](lena.bmp)

灰度：

![](lena_grayscale.png)

### 子任务2 尝试用不同方式对图片进行 DCT

代码在 `lena_dct_exp1.py` 中。

第一个方法是，先对行再对列进行 DCT ，第二个方法是，对整个图进行 DCT，这两个方法在数学上是等价的，只不过在后面 1/4 1/16 和 1/64 时权值的选取上可以有不一样的结果，后面会继续讨论。

第三个方法则是分割成 8x8 以后进行 DCT。

第一个和第二个方法得到的DCT的图：

![](lena_2ddct.png)

可以看到，左上角的数值是比较大的，其他地方的数都很小，比较符合 DCT 的特征。

切分为 8x8 以后也有类似的分布：

![](lena_2ddct_8x8/lena_2ddct_0_0.png)

![](lena_2ddct_8x8/lena_2ddct_3_55.png)

也是只有左上角一到两个像素比较大。

在运行时间上，设图片都是正方形，边长为 n ，那么第一种方法需要循环 n * n * n * 2 ，第二种方法需要 n * n * n * n 次，第三种方法需要 8 * 8 * 8 * 8 * (n/8) * (n / 8) = 64 * n * n ，当 n 比较大的时候第三种方法最快。

代码输出了对应的 PSNR 值。由于第一种方法和第二种方法在数学上是相等的，代码中只用了第一种方法进行计算，得到 PSNR 为 315.48 ，比第三种方法的 PSNR 315.45 略大，说明考虑到计算精度的时候，第一种方法比第三种方法能留下更精确的信息。

接着对 DCT 之后的系数进行了“压缩”，题目要求 1/4 1/16 和 1/64 ，首先对 8\*8 的格子进行了 DCT 系数的选取，方法是，如果是 1/4 ，则在每个 2\*2 的子格子中选取左上角的那一个，其它依此类推。再用 IDCT 恢复到原来的图像，对比如下：

直接还原：

![](lena_2ddct_8x8_2didct.png)

1/4 的情况：

![](lena_2ddct_8x8_4_2didct.png)

1/16 的情况：

![](lena_2ddct_8x8_16_2didct.png)

1/64 的情况：

![](lena_2ddct_8x8_64_2didct.png)

可以看到，随着压缩率不断增加，图片清晰度也逐渐下降，但仍然保留了比较多原始的信息。由于分块是按照 8x8 的，所以最后 1/64 比例时，每个 8*8 的块都是同一个像素值，显示出了明显的颗粒感。

直接对 2D DCT 进行类似的系数选取后，即对整个图片计算 2D DCT 后，保留左上角的一片系数，剩下都设置为 0，再 IDCT 恢复：

原始图片：

![](lena_2ddct_2didct.png)

1/4 的情况：

![](lena_2ddct_4_2didct.png)

1/16 的情况：

![](lena_2ddct_16_2didct.png)

1/64 的情况：

![](lena_2ddct_64_2didct.png)

可以看到，图片压缩率越高，清晰度也在不断下降，但是下降的形式和之前 8*8 时不大一样。因为是直接对全图的 DCT 系数进行压缩，所以在 1/64 的时候看到一些很明显的波纹，这些对应着留下来的部分 DCT 系数。

接下来是采用 PPT 文档中所描述的 DCT 系数选取方法，即先对行进行 DCT ，选取一半的列以后，对这一部分再进行 DCT ，剩余部分都为 0 。按照这样的策略，得到的图片为：

原始图片

![](lena_1ddct_1didct.png)

1/4:

![](lena_1ddct_2.png)

1/16:

![](lena_1ddct_4.png)

1/64:

![](lena_1ddct_8.png)

可以看到，也出现了一些比较明显的线条，和之前的结果类似。虽然操作顺序不同，但和之前 2D-DCT 最后取左上角的结果是一致的，所以最后得到的图片也是一样的，只是在运行时间上不一样而已。

## Exp2 Why quantization is so important?

